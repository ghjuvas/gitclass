## Тема: Линейный поиск, бинарный поиск, тернарный поиск  
##### *Линейный поиск*    
Есть книжная полка, где книги расставлены не по порядку. Чтобы найти книгу, нам нужно проверять каждую книгу подходит ли она нам.  

	[names]  
	for i in range (len(names)):  
    	if names[i] == wtf:  
        	return True  
	return False  
    
Можно сделать элегантно 

	i= 0
	while i < len(names) and names[i] != wtf:
		i += 1
	return i < len(names) #проверить, что i не вышло за линии массива


##### *Бинарный поиск* 
log<sub>2</sub>1000 < log<sub>2</sub>1024 = 10 – количество вопросов, которое нам нужно задать, чтобы узнать какое число загадали от 2 до 1000.

Дана отсортированная последовательность х = 15   
1<sub>L</sub> 7 8 __12__ 18 23 27 31<sub>R</sub> 

Давайте посмотрим на среднее число. Вопросы, которые мы задаем: правда ли, что число, на которое мы смотрим, меньше или равно х.
Правда ли 12 меньше или равно х? Да, значит мы сдвигаем L  
1 7 8 __12__<sub>L</sub> 18 23 27 31<sub>R</sub>

Правда ли, что 23 меньше или равно х? Нет, сдвигаем правую.    
1 7 8 __12__<sub>L</sub> 18 23<sub>R</sub> 27 31

Правда ли, что 18 меньше или равно х? Нет, сдвигаем правую. У нас накладываются границы. Значит числа 15 у нас в массиве нет.


||L|R||
|:---|:--|---:|:---| 
|1|<| >| __12__ 15 __18__
|2|≤|>|12 __15__ __18__|
|3|<|≥|__12__ __15__ 18|
|4| ≤| ≥|12 __15__ 18|    

В 4 происходит наслонение  
1 и 4 не подходит

|Ост.|L|R||
|:---|:--|---:|:---|
|L == R| [| ]| [ 1, 2, 3, 4, 5]
|R - L = 1| [ | )| [1, 2, 3, 4, 5)
|R -L = 1| (| ]| (1, 2, 3, 4, 5]
|R - L == 2| (| )| (1, 2, 3, 4, 5)

Когда у нас останется одно число? (см. ост.)

|Ост.|L|R|Среднее число|
|:---|:--|---:|:---|
|L == R| [| ]| 
|R - L = 1| [ | )| (L + R) / 2
|R -L = 1| (| ]| (L + R) / 2
|R - L == 2| (| )| 


Шаблон

	L = 0           [ 
	R =MAX + 1      )
	while R – L > 1:
    	m = R + L // 2
    	if check (m):
        	L = m
    	else:
        	R = m 

##### *Тернарный поиск* - это метод в информатике для поиска максимумов и минимумов функции, которая либо сначала строго возрастает, затем строго убывает, либо наоборот.

##### Задачи с семинара

Задача №1  

	#У Гриши есть N дипломов размеров AxB см. Гриша хочет доску YxY см.
	#Какая доска нужна Грише, чтобы вместить все дипломы?

	def diplomas(y, a, b):
    	return (y // a) * (y // b) #размердиплома

	N = int(input())
	a, b = map(int, input().split())

	def slow_sol(a, b, N): #медленное решение
    	d = 1
    	while diplomas(d, a, b) < N:
        	d += 1
    	return d


	def fast_sol(a, b, N): #быстрое решение, используем бинарный поиск
    	l = 0 #минимальный размер доски (
    	r = max(a, b) * N #максимальный размер доски ]
    	# l < d <= r
    	while r - l > 1:
        	m = (r + l) // 2 #среднее число
        	if diplomas(m, a, b) < N: #если строго меньше чем N, то сдвигаем l
            	l = m
        	else: #если больше или равно чем N, то сдвигаем r
            	r = m
    	return r

Задача №2

	# Бургеры
	# а листов салата, b котлет, с булочек
	# pa, pb, pc, - стоимость
	# ra, rb, rc - кол-воингридиентов на бургергер
	# N рублей
	# Сколько бургеров получится приготовить?

	a, b, c = map(int, input().split())
	pa, pb, pc = map(int, input().split())
	ra, rb, rc = map(int, input().split())
	N = int(input())


	def can_make(d):
    	da = ra*d #кол-во салата для d бургеров
    	db = rb*d #кол-во котлет для d бургеров
    	dc = rc*d #кол-во булочек для d бургеров

	#Проверяем наличие
    	da -= a
    	db -= b
    	dc -= c

	#стоимость d бургеров
    	buy_bill = max(0, da) * pa + max(0, db) * pb + max(0, dc) * pc
    	return buy_bill <= N

	def slow_sol2(): # O(n)
    	d = 1
    	while can_make(d):
        	d += 1
    	return d - 1

	def fast_sol2(): #O(log(n))
    	l = 0
    	r = N + max(a, b, c)
    	# L <= d < R строгое количество денег

    	while r - l > 1:
        	m = r + l // 2
        	if can_make(m):
            	l = m
        	else:
            	r = m
    	return l 

	# Бургеры
	# ingridients - имеющееся кол-во
	# costs - стоимость
	# recipe - кол-воингридиентов на бургергер
	# N рублей
	# Сколько бургеров получится приготовить?

	ing = list(map(int, input().split()))
	costs = list(map(int, input().split()))
	recipe = list(map(int, input().split()))
	N = int(input())

	def can_make(d): #O(n)
    	buy_bill = 0
    	for i in range(len(ing)):
        	buy_bill = max(0, recipe[i]*d - ing[i]) * costs[i]
    	return buy_bill <= N



 

